#include "global.h"procedure WriteTableId;begin  writeln('table.p 1.16') end;procedure InitVariableTable;var J: 0..VariableTableSize;begin  for J := 0 to VariableTableSize do    VariableTable[J] := nil end;function GetVariable;var  H: StringIndex;                   (* Used to find the end of the variable *)  HashValue: 0..VariableTableSize;  (* Becomes the hash bucket index *)  Save0, Save1: char;               (* Part of a kludge to use StringEqual *)  VarPtr: PointerToVariable;        (* Becomes a pointer to the sought record *)  ShadowPtr: PointerToVariable;     (* The shadow of VarPtr *)  Done: boolean;                    (* Used to control a loop. *)begin  HashValue := 0;  H := VarName;  while (not(StringPool[H] in DelimiterSet)) do begin    HashValue := (HashValue + ord(StringPool[H])) mod VariableTableSize;    H := H + 1 end;  (* In case there isn't one there already, we insert a string   * end so that StringEqual will work properly.   *)  Save0 := StringPool[H];  Save1 := StringPool[H+1];  StringPool[H] := '/';  StringPool[H+1] := ')';  VarPtr := VariableTable[HashValue];  repeat    if VarPtr = nil then       Done := true    else      Done := StringEqual(VarName, VarPtr^.Name);    if not Done then      VarPtr := VarPtr^.BucketMate;  until Done;  if (Option <> Create) and (VarPtr = nil) then begin    write('undeclared variable: ');    WriteString(output, VarName);    writeln;    Abort end;      case Option of  (* See next comment *)  GetActual: GetVariable := VarPtr;  GetShadow: GetVariable := VarPtr^.BucketMate;  GetEither:    if Save0 = '@' then      GetVariable := VarPtr    else      GetVariable := VarPtr^.BucketMate;  Create: begin    if (VarPtr <> nil) then begin      write('duplicate declaration for ');      WriteString(output, VarName);      writeln;      Abort end    else begin      if EnvLength+2 > MaximumAllowedVariables then begin	writeln('variable overflow');	Abort end;      new(VarPtr);      GetVariable := VarPtr;      new(ShadowPtr);      with VarPtr^ do begin        Name := VarName;        Index := EnvLength;        VariableWithIndex[Index] := VarPtr;	Kind := Actual;	BucketMate := ShadowPtr;        OnList := false;        StatusStack := nil end;      (* ShadowPtr looks just like VarPtr, except for three fields.       * Note that the shadow variable always follows the actual variable       * in the bucket list.  We will use this fact when looking up variables.       *)       ShadowPtr^ := VarPtr^;      with ShadowPtr^ do begin	Kind := DefinedShadow;	Index := EnvLength + 1;        VariableWithIndex[Index] := ShadowPtr;	BucketMate := VariableTable[HashValue] end;      VariableTable[HashValue] := VarPtr;       EnvLength := EnvLength + 2 end end  end;  (* Undo the damage we did when we inserted the string end. *)  StringPool[H] := Save0;   StringPool[H+1] := Save1 end;      procedure InitKeywordTable;var X: integer;procedure Insert(S: ShortString; K: Keyword);(* Input: S, K, Keyword table. * Output: Keyword table. * Effect: Associate the string S with the keyword K in the *  keyword table (without changing other associations). *)var  KeyString: StringIndex;       (* String value of read keyword *)  HashKey: integer;             (* Hash value of read keyword   *)  HashTry: 0..KeywordTableSize; (* Location of probe *)  X: integer;begin  KeyString := NextString;  HashKey := 0;  X := 1;  while S[X] <> ' ' do begin    HashKey := HashKey + ord(S[X]);    PutStringPool(S[X]);    X := X + 1 end;  PutStringEnd;  HashTry := HashKey mod KeywordTableSize;  (* Make two attempts at finding an empty slot,   * which is marked by the token EmptySlot.   *)  if KeywordTable[HashTry].KeyCode <> EmptySlot then begin    HashTry := (HashTry + ord(S[1])) mod KeywordTableSize;    if KeywordTable[HashTry].KeyCode <> EmptySlot then begin      writeln('keyword collision');      Abort end end;  with KeywordTable[HashTry] do begin    KeyCode := K;    Spelling := KeyString end end;begin  for X := 0 to KeywordTableSize-1 do    with KeywordTable[X] do begin      KeyCode := EmptySlot;      Spelling := NullString end;  Insert('ASSIGN  ', AssignK);  Insert('BEGIN   ', BeginK);  Insert('BRANCH  ', BranchK);  Insert('END     ', EndK);  QuoteBREAK := NextString;  Insert('BREAK   ', BreakK);  Insert('HANG    ', HangK);  Insert('JOIN    ', JoinK);  Insert('NEW     ', NewK);  Insert('REIN    ', ReinK);  Insert('RENEW   ', RenewK);  Insert('REOUT   ', ReoutK);  Insert('REQUIRE ', RequireK);  Insert('PROCLAIM', ProclaimK);  Insert('SPLIT   ', SplitK);  Insert('WHEN    ', WhenK) end;procedure AddLabel;var B: 1..LabelTableSize;     (* Hash bucket index *)    N: PointerToLabelNode;    (* LabelNode for L *)    Done: boolean;            (* Loop-end flag *)    ProperClass: LabelType;   (* Class of LabelNode needed for J *)begin  if L <> 0 then begin    (* Determine what kind of LabelNode we need *)    case J^.Jtag of    SplitN, WhenN:    ProperClass := SplitWhen;    BranchN, JoinN:   ProperClass := BranchJoin;    end;    (* Determine which bucket the node should be in *)    B := ((L-1) mod LabelTableSize) + 1;    (* Extend the usable Label Table out to B (if necessary) *)    while MaxLabelBucket < B do begin      MaxLabelBucket := MaxLabelBucket + 1;      LabelTable[MaxLabelBucket] := nil end;    (* Search bucket B for L *)    N := LabelTable[B];    repeat      if N = nil then        Done := true      else         Done := (N^.LabelVal = L);      if not Done then N := N^.BucketMate    until Done;    (* Make N the LabelNode for L, creating one if necessary *)    if N = nil then begin      (* Allocate a new LabelNode and fill in default values *)      new(N);      with N^ do begin        BucketMate := LabelTable[B];        LabelTable[B] := N;        LabelVal := L;        Class := ProperClass;        One := nil;        Many := nil;        HowMany := 0 end end    else begin      (* Make sure existing node has the right class *)      if N^.Class <> ProperClass then begin 	writeln(L:1, ' is a mixed label');	Abort end end;    (* Update N on the basis of what kind of node J is *)    with N^ do      case J^.Jtag of      SplitN, JoinN: begin        if One <> nil then begin          writeln(L:1, ' is a duplicate label');	  Abort end        else          One := J end;            WhenN: begin        J^.WhenMate := Many;        Many := J;        HowMany := HowMany + 1 end;      BranchN: begin        J^.BranchMate := Many;        Many := J;        HowMany := HowMany + 1 end end end end;    procedure DismantleLabelTable;var B: 1 .. LabelTableSize; (* Used to cycle through Label Table *)    N: PointerToLabelNode;  (* Used to cycle through a bucket *)    M: PointerToJnode;      (* Used to cycle through a Many list *)    DeleteCount, D: integer;     P, Q: PointerToJnode;   (* Used to scan lists and delete nodes *)begin  DeleteCount := 0;  if MaxLabelBucket >= 1 then		(* avoid compiler bug on null FOR *)  for B := 1 to MaxLabelBucket do begin    N := LabelTable[B];    while N <> nil do begin      (* This loop body is executed with N = every LabelNode *)      with N^ do begin        if One = nil then begin          writeln('No defining occurrence of label ', LabelVal:1);	  Abort end	(* A SPLIT without at least two WHENs is considered to be	 * an error.  A BRANCH with only one JOIN is syntactically	 * allowed, the resulting graph messes up the computation	 * of dominators.  We allow that case here, but later delete	 * the offending nodes from the graph.	 *)	else if (HowMany = 0) or		(One^.Jtag = SplitN) and (HowMany = 1) then begin	  writeln('Too few uses of label ', LabelVal:1);	  Abort end        else if One^.Jtag = JoinN then begin	  if HowMany = 1 then begin	    (* A BRANCH has only one JOIN.  This pair of nodes can	     * be removed from the graph without changing its semantics.	     * In fact, we must delete them to avoid problems with	     * dominator computation.	     *)	    Many^.Previous^.Next := One^.Next;	    if One^.Next <> nil then	      One^.Next^.Previous := Many^.Previous;	    (* Mark the nodes to be deleted.  After we find all the	     * nodes that must be deallocated, we will make one pass	     * through the OtherList and JoinList and deallocate them all.	     *)	    assert(Many^.Jtag = BranchN);	    Many^.Visited := true;	    One^.Marked := true;	    DeleteCount := DeleteCount + 1 end	  else begin	    (* Link up the JOIN and the corresponding BRANCHes *)	    One^.Previous:= Many;	    M := Many;	    while M <> nil do begin	      M^.Next := One;	      M := M^.BranchMate end;	    One^.InDegree := HowMany end end	else (* assert One^.Jtag = SplitN *) begin	  (* Link up the SPLIT and the corresponding WHENs *)	  One^.Next := Many;	  M := Many;	  while M <> nil do begin	    M^.Previous := One;	    M := M^.WhenMate end end;        (* Unchain the LabelN node... *)        LabelTable[B] := BucketMate end;      (* ...and delete it. *)      dispose(N);      N := LabelTable[B] end end;    (* Make a pass through the JoinList and delete all the marked   * JoinN nodes.   *)  D := DeleteCount;  P := nil;  while D <> 0 do begin    (* Loop invariants:	 D nodes are left to be deleted.	 If P is nonnil, then all nodes to be deleted come after P	   in the list. *)    (* Q is the first node that might need to be deleted *)    if P = nil then       Q := JoinList    else       Q := P^.SimLink;    if Q^.Marked then begin      (* Delete Q *)      if P = nil then	JoinList := Q^.SimLink      else	P^.SimLink := Q^.SimLink;      dispose(Q, JoinN);      D := D - 1 end    else      P := Q end;  (* Make a pass through the BranchList and delete all the marked   * JoinN nodes.   *)  D := DeleteCount;  P := nil;  while D <> 0 do begin    (* Loop invariants:	 D nodes are left to be deleted.	 If P is nonnil, then all nodes to be deleted come after P	   in the list. *)    (* Q is the first node that might need to be deleted *)    if P = nil then       Q := BranchList    else       Q := P^.SimLink;    if Q^.Visited then begin      (* Delete Q *)      if P = nil then	BranchList := Q^.SimLink      else	P^.SimLink := Q^.SimLink;      dispose(Q, BranchN);      D := D - 1 end    else      P := Q end end;