#include "global.h"#include 'unixio.h'procedure WriteChangedId;begin   writeln('changed.p 1.7') end; function VerifyJunit: boolean;(* Input: p3jcode; * Output: standard output. * Effect: Attempt verification of the J-unit that begins at the position of *   the current file pointer for p3jcode.  If the verification fails, *   diagnostics are sent to the standard output.  Return a boolean indicating *   whether or not the verification was successful. *)begin  (* if there was junk left over from the last verification, get rid of it.   * The reason for the variable Dirty is so we don't clean up after the   * last verification, only to exit.   *)  if Dirty then CleanUp;  (* Prepare to verify a unit *)  InitUnit;  TPunitBegin;  (* Read in the unit, building an incomplete J-graph *)  ReadUnit;  Dirty := true;  (* Complete the construction of the J-graph *)  FinishGraph;  (* Trace all the paths of the J-graph, and indicate if any errors   * were found.   *)  VerifyJunit := PathTrace;  TPunitEnd end;procedure VerifyChangedUnits;type   SearchState =      (* The following is really only relevant to procedure Advance *)    (DoesNotBeginWithEND,  (* Line window is no does not begin END *)     SearchBegin,          (* Window is over the beginning of a line *)     Ew,                   (* Line contianing window begins with E, and			    * the window is one past the E.			    *)     ENw,                  (* Same as above, except window is after EN *)     ENDandMore,           (* Line window is on begins END, window is not			    * yet over end of line *)     SearchDone);          (* Window is on beginning of line after the			    * one with the end.			    *)  Relation = (Less, Equal, Greater);function ReadAndCompare(var F1, F2: text): Relation;(* Input: F1, F2. * Output: through function name. * Assumption: F1^ and F2^ are each over the beginning of a line. * Effect: Read a line L1 from F1 and a line L2 from F2.  Compare L1 and *   L2 lexicographically.  Return Less, Equal, or Greater to indicate *   L1=L2, L1<L2, and L1>L2. *)label 1; (* go there when you figure out the answer *)begin  (* read the lines until we get a mismatch or one of the strings ends on us *)  while (not eoln(F1) and not eoln(F2)) do begin    if F1^ < F2^ then begin      ReadAndCompare := Less;      goto 1 end;    if F1^ > F2^ then begin      ReadAndCompare := Greater;      goto 1 end;    get(F1);    get(F2) end;  (* The strings are the same up until one ended.  If both were the same   * length, then they are equal, otherwise the short one is smaller.   *)  if eoln(F1) and eoln(F2) then    ReadAndCompare := Equal  else if eoln(F1) then    ReadAndCompare := Less  else (* assert eoln(F2) *)    ReadAndCompare := Greater;  1: (* Make sure each of the strings has been completely read *)  while not eoln(F1) do get(F1);  while not eoln(F2) do get(F2);  get(F1); get(F2) end;procedure Advance(var F: text; var S: SearchState);(* Input: F, S, EndString * Output: S * Assumption: EndString[1..3] contains 'END'. * Effect: Advance is used to move the file window of F ahead a character *    at a time, looking for the end of a J-unit.  The last line of a J-unit *    begins with the characters 'END'.  The first call to Advance should *    supply SearchBegin as a state.  Subsequent calls should use the value *    returned by the last call.  When the file window is over the first *    character after then line end of the line beginning END, Advance *    will return SearchDone as a state. *)begin  (* All of the follwing make sense if you understand what all of the   * states represent.  See the comments at the type declaration of   * SearchState.   *)  if eoln(F) then begin    if S = ENDandMore then      S := SearchDone    else      S := SearchBegin end  else begin    if S in [SearchBegin, Ew, ENw] then begin      if F^ = EndString[ord(S)] then	S := succ(S)      else	S := DoesNotBeginWithEND end end;   get(F) end;procedure CopyUnit(var Source, Destination: text);(* Input: Source * Output: Destination * Assumptions: Source^ is the beginning of a line (that is, one past a line *    end character; Sufficent reading of Source will find the sequence of four *    characters: <line end>, E, N, D . * Effect: Read charaters from the file Source until the line containing *    the END line has been read.  Add this sequence of characters to the *    end of Destination. *) var State: SearchState;begin  State := SearchBegin;  repeat     if eoln(Source) then       writeln(Destination)     else       write(Destination, Source^);     Advance(Source, State);     until State = SearchDone;     end;function JunitCompare(var F1, F2: text): boolean;(* Input: F1, F2 * Output: through function name * Assumptions: F1^ and F2^ are each at the beginning of lines *   (that is, one past a line end character).  Sufficent reading of S1 *   and will find the sequence of four characters: <line end>, E, N, D . *   Any occurrence of `{' in F1 or F2 is followed by a matching `}' that *   occurs before the line end sequence. * * Effect:  *    Read F1 and F2 up to and including the next END line of each. *    Return a boolean indicating whether or not the characters read from *    each of the files would be identical if all sequences starting with *    `{' and continuing up to the next '}' were deleted, and all line end *    characters were replaced with blanks. *) label 1; (* go there when you know what the answer is *)var S1, S2: SearchState;begin  (* Scan F1 and F2, looking for differences *)  S1 := SearchBegin;  S2 := SearchBegin;  repeat    if F1^ <> F2^ then begin	JunitCompare := false;	goto 1 end;    (* assert F1^ = F2^ *)    (* Ignore any characters inclosed in braces *)    if F1^ = '{' then begin      repeat get(F1) until F1^ = '}';      repeat get(F2) until F2^ = '}' end;    Advance(F1, S1);    Advance(F2, S2);    until ((S1 = SearchDone) or (S2 = SearchDone));  JunitCompare := S1 = S2;  1: (* Make sure all files have been read to the end *)  while (S1 <> SearchDone) do Advance(F1, S1);  while (S2 <> SearchDone) do Advance(F2, S2) end;    procedure SkipUnit(var F: text);(* Input: F * Output: none * Assumptions: F^ is the beginning of a line (that is, one past a line *    end character; Sufficent reading of F will find the sequence of four *    characters: <line end>, E, N, D . * Effect: Read (and discard) characters from the file F until the END line *    has been read. *) var S: SearchState;begin  S := SearchBegin;  repeat Advance(F, S) until S = SearchDone;  end;function VerifyAndCopy: boolean;(* Input: p3jcode * Output: newhistory * Assumption: p3jcode^ is at the beginning of a J-unit, on the B in BEGIN. * Effect: Read the unit (up to and including the END line), *    generate verification conditions, and send the conjectures to the *    theorem prover.  If all are proved, put a copy of the complete J-unit *    (from BEGIN to END) into newhistory. *)var  Mark: fileptr;  Verified: boolean;begin  Mark := TELL(p3jcode);  Verified := VerifyJunit;  SEEK(p3jcode, Mark);  if Verified then     CopyUnit(p3jcode, newhistory)  else    SkipUnit(p3jcode);    VerifyAndCopy := Verified end;function Merge: boolean;(* Input: p3jcode, history. * Output: through function name, newhistory * Assumption: p3jcode and history contain j-units that are sorted *   in increasing lexical order, using their first lines as keys. * Effect: The file newhistory is formed by concatenating all the correct *   junits in p3jcode (preserving their sorted order).  If a unit is in *   history, it is assumed to be correct.  The correctness of other units *   is decided by calling VerifyJunit.  The  boolean returned indicates *   whether all the units in p3jcode were correct. *)var Jmark,  (* saved position in p3jcode *)    Hmark:  (* saved position in history *)	    fileptr;OKsoFar: boolean;  (* True iff all j-units processed have been correct *)begin  reset(p3jcode);  reset(history);  rewrite(newhistory);  OKsoFar := true;  while not eof(p3jcode) do begin    if eof(history) then      (* There is no more history file; simply verify the rest of       * of the J-units in p3jcode.       *)      repeat	OKsoFar := OKsoFar and VerifyAndCopy	until eof(p3jcode)    else begin      Jmark := TELL(p3jcode);      Hmark := TELL(history);       case ReadAndCompare(p3jcode, history) of      Less: begin	(* Keep the current Hunit and verify the Junit *)	SEEK(history, Hmark);	SEEK(p3jcode, Jmark);	OKsoFar := OKsoFar and VerifyAndCopy end;      Greater: begin	(* Keep the current Junit, but skip to the next Hunit *)	SEEK(p3jcode, Jmark);	SkipUnit(history) end;      Equal: begin	(* Compare the two units-- whatever happens, advance past both. *)	if JunitCompare(p3jcode, history) then begin	  (* The units are the same (and therefore correct).	   * Put the unit in the new history file.	   *)	  SEEK(p3jcode, Jmark);	  CopyUnit(p3jcode, newhistory) end	else begin	  (* The units are different, so the Junit may not be correct.	   * Verify it.	   *)	  SEEK(p3jcode, Jmark);	  OKsoFar := OKsoFar and VerifyAndCopy end end end end end;  (* All units have now been processed, so that "so far" is now "everthing." *)  Merge := OKsoFar end;begin  if Merge then begin    (* return a good status *) end  else    halt (* returning a bad status *) end;