#include "global.h"procedure WriteStringId;begin  writeln('string.p 1.5') end;procedure PutStringPool;begin  if NextString = StringPoolSize then begin    writeln('string overflow');    Abort end  else begin    StringPool[NextString] := C;    NextString := NextString + 1 end end;procedure PutStringEnd;begin  PutStringPool('/');  PutStringPool(')') end;function StringEqual;var Result: (Yes, No, Unsure);begin  Result := Unsure;  repeat    if StringPool[A] <> StringPool[B] then      Result := No    else begin      if StringPool[A] = '/' then        if (StringPool[A+1] = ')') and (StringPool[B+1] = ')') then          Result := Yes end;    A := A + 1;    B := B + 1  until Result <> Unsure;  StringEqual := Result = Yes end;function StringCreate;var X: 1..ShortStringLength;begin  StringCreate := NextString;  X := 1;  PutStringPool(S[1]); (* So that S[X-1] does not overflow *)  repeat    X := X + 1;    PutStringPool(S[X])  until (S[X-1] = '/') and (S[X]=')') end;procedure ShortAppend;var NotUsed: StringIndex;begin  NotUsed := StringCreate(S);  NextString := NextString - 2 end;procedure StringCopy;begin  PutStringPool(StringPool[A]);  repeat    A := A + 1;    PutStringPool(StringPool[A]);  until (StringPool[NextString-2] = '/') and        (StringPool[NextString-1] = ')') end; procedure StringAppend;begin  StringCopy(A);  NextString := NextString - 2 end;